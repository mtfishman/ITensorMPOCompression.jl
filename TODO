Questions:
  -Should we be using findinds or just inds?
  -Delete old branches, after merge?
  -Future of Model("model_name") framework.
  -verbose mode? (only see it in ctmrg)
  Yes -Is there use for a moving orthogonality center in MPOs? Yes see Matts email March/14/2023
  -Do we need to support multiple truncate sweeps for iMPOs?
  -Should orthognalize!(iMPO) spit out primed Gs?
  -Support RQ/QL/LQ in factorize?
  -InfiniteMPO using llim=b-1,rlim=b+1 for b=orthcenter(H) fails when N=1, because 
   left/right/unorth all become indistinguishable.
  	
  
More tests:
-vumps GS example with timing for uncomp./comp.
  vumps works on InfiniteMPOMatrix or InfiniteSum{MPO}, but compression needs InfinitMPO
  So they are "disconnected" for now.
-Try apply gate.
  Reg form gets destroyed as expected.  Doing UvS -->  lq(U), I can see the reg form in L
  but the bottom right I op is hiding as a liner combination of S ops.
-Test with Julia 1.7 and 1.8

Features:
-Put some content in Readme.md
-make truncate, and orthogonalize that work on copies.

Bugs:
Done: -Fix:   iMPO After left orth sweep, 3 iterations Dw reduced from 1 to 4
-2-body Hamiltonian in trancate fail.
-Truncate iMPO make_transIsing_iMPO NNN=4 has a gauge problem.
  Maybe just need 2 more orth sweeps (Auto iMPO is fine)

Improvements requiring changes to other modules:
-Save regular_form upper/lower/irreg/unknown in the MPO struct so we never have to call
 detect_regular_form.
   This requires a mod to ITensors MPO struct

Improvements:
-assign!() is still wildley inefficient.  We need a way to do
  W[r=>1,c=>1]=op where order(op)==2 and order(W)==4
  at the NDTensors level.
-Organize exports and imports.
-Subtensor check flux of inserted blocks.
-Subtensor cleanup.
-subtensor  support W[il,ir]=op ?
-better name for pbc? inf open_chain, boundary_conditions
-Consider default rr_cutoff=1e-14?
-Refactor out all the link fixing and PBC code for MPO making functions.
-iMPO truncate fails with a trivial 2x2 hamiltonian.

-Add support for swapxz flag in trans-ising Hamiltonian
  -Change Hx flag to just h.
-Support Ncell>1 in InfinitSum{MPO}(InfiniteMPO)  constructor.
-Bug report for ITensorInfiniteMPS crash in Hx SzSz model
  -Try and fix the bug
-Look at InfinitSum{ITensor}
-Understand factor of 2*J*Xn*Xn+1 in Model("ising")
-Make a Model("ising_NNN") for arbitrary NNN interactions.
-Make a table of Ncell for sites, and length(mpo) nsites(His) so we can figure what the rules are.
-Search for TODO items and get them in this list.
Don't need: -block_qx Instead restoring full tri form, just use the part of the perm than puts I back in the corner.  
    i.e.   leave the A block scrambled.
-System for hamitonians make_Hubbard_AutoiMPO => Hubbard_Auto_iMPO
-Use an infinite=true flag for iMPOs?
-Clean up "where {Elt,N}" code.
-Get rid of getV1 and setV1.  i.e. make all order(W)==4 by adding dummy indices.
-Follow Matts kwargs guidelines
-Eliminate use of tags for finding indices.  Use the network structure instead.  Pass list if indices
  in function calls.  Use linkinds, commoninds, uniqueinds.
-For iMPOs set llim,rlim=-1,1 so that they are interpreted as non-ortho when N=1.
-iMPO truncate user HL,HR instead of H,Hm ?
-Go over all the Problems in VScode.  Are they real?
-format
-Move code into compression module.
Ac blocking code:
-no method matching order(::ITensorMPOCompression.reg_form_Op)
-Fix Index Tag conventions sections of the docs.

Fix Unknown:
-For RL_prime problems, try factor R+ = R'*M (instread of M*R) then R' will be square.
  THis will only work if R' is orthogonal R_dagger'*R' = Id

julia --sysimage /home/janr/.julia/sysimages/sys_itensors.so

open("/home/janr/prof1.txt", "w") do s
           Profile.print(IOContext(s, :displaysize => (24, 500)),format=:flat)
       end


       

Old:
Done: -parse_links ... accept n=1 for link indices.
 Done: -Take out the h_mirror feature.
Done: -Test with pivoting
Ac blocking code:
  Done 2) -add_dummy_links! return irs,ils for left and right links.  Less dag calls.  harmonize ortho/gauge_fix!
    loops.  No more N+1 indexes.  
  Done: 1) -make remove_dummy_links!, remove_dummy_links, has_dummy_links.  name: edge_links?
  Done: 3) -use vector(t) .. make a short function to get the Dw=1 index first.
  -extract_blocks onlt swap b,c blocks if user requests.  Handle ilb,ilf based on ms
  Done: 4) -ac_qx check that dh is near interger.
  Done: 7) -set_ð‘¨ð’„_block  use space(ilf) to get first and last QN blocks.  Use a simplified redim function
  Done: 8)   grow(il,R,ir)  should do the same thing.
  Done: 5) -set_ð‘¨ð’„_block  lower-left==upper-right for preserving corners and one row/col
  Done: 6)  same in gauge_fix!(W...)
  Done: 9) -gauge_fix! use a set_c function
  Done: 10) -Fix all noprime(A,tags="Link") calls.
  Done: 11) -Refactor set_ð‘¨ð’„_block into
        Done: a) newQ() which makes Wp, preserves columns and Is
        Done:b) call set_ð‘¨ð’„_block or set_ð‘¨b_block
        Done:c) set_ð‘¨ð’„_block calls set_ð’„_block is nr==1
        Done:d) set_ð‘¨b_block calls set_b_block is nr==1
  Done: -Make a struct MPO_with_links,  has ils, irs, ul, d0,dN
  Done:   Same Op_with_links il,ir,ul
    -Ask Matt if he is already doing this?
  Done:   -Do QR pivot PR first.
Fixed: -Incomplete block transfer: truncate (make_transIsing_MPO,upper,"S=1/2"),
Done: -Replace RL with X in bock_qx.
Done: -refactor gauge fix in Block QX
Done: -Clean up getM()

Done: -MPO truncate Heisenberg AutoMPO
Done: -MPO truncate ... don't switch to dense for svd(M) ... need to preserve QN structure
Done: -Get Heisenberg AutoMPO iMPOs working (Need to handle case where NNN>N)
Done: -Upper reg-form from autompo
Done: -iMPO from AutoMPO
Done: -Test alternating S=1/2 and S=1 sites for MPO.
Done: -Test alternating S=1/2 and S=1 sites for iMPO.
Done: -Test Heisenberg model from autoMPO with non-trivial QN space structure on Link indices.
Done: -Test Fermions/Hubberd.

Done: -If user doesn;t set rr_cutoff, set to 1e-15
Done: -Enforce expected type for all get(kwargs) calls
Done: - use maxlinkdim for maxlinkdim
Done: -Review high level algos
  MPO truncate should iterate until no bailouts.
-Done: convergence in truncate for finite MPO?
  -Keep sweeping until there are no bailouts.
 
No: -rr_cutoff=0.0 not allowed in truncate?
Not a bug: -Handle 3 site unit cell for iMPO with QNs.
  This crashed when creating sites inside ITensorInfiniteMPS with error:
  Dividing ITensors.QNVal(SzParity, 1, 2) by 3, the resulting QN value is not an integer
Done -iMPO, if Ncell=1 the left/right tags of H[1] are the same.  We need to prime one of them
  prior to truncation, maybe during or prior to orthogonalization.
- Check for unit ops along the diagonal: For rectangluar matrices we seem to be looking a the  wrong diagonal.
Done: -Can we use linkind(MPO,bond::Integer) to get link indices? Less use or parsle_links?
Done: -User llim and rlim in MPO/iMPO structs to save ortho status.
  -unortho llim=0, rlim=N+1
  -Ortho on b llim=b-1, rlim=b+1
  -Useful functions in abtractmps.jl: leftlim rightlim setleftlim! setrightlim! ortho_lims
    set_ortho_lims! reset_ortho_lims! isortho orthocenter 
    linkind linkinds defaultlinktags hasdefaultlinktags eachlinkinds eachsiteinds
  -Encountered ambiguity problems with iMPO when N=1.
Done: -Clean up index matching in SetV
Done: -Pare down unit test for shorter run time.
  -Very hard, lots of CPU time on compiling inside ITensors for GS energy tests
  -Using a sysimage for ITensors does not seem to help!
Done: -Profile and code coverage.
   Spends most of the time in detect_regular_form.  We should keep this info in the MPO
   struct.
Done: -Gs/Ss returned by truncate should be Diag not Dense tensors.
Done: -Use new is_upper functions using combiners to get rank-2 tensors.
   Not sure the combiners do what we want here for an op-valued matrix.
   Using norm and no slice to test for zeros
Done: -Add some sort of Results section at the end ot tech docs.
Done:  -rules for smart_sweep
Done:  -orthog inside truncate
Done: -Switch from epsrr to rr_cutoff
Done: -Clean up SetV code.  Use dummy Dw=1 index trick instead of SetV1 code.
Done: -clean up kwargs=Dict(kwargs) is not needed.
Done: -qx_iterate! clean up GS init loop

Done: -Verbose mode show all Dws and steps orth-right etc.
  Done: -subtensor function
  	-Must handle block sparse
  	-I only need it for link indices
  	-Do the work in NDTensors

Done: -Does block_qx really need to know n?
  Instead of r,c index we should really think in terms of f,r = forward, reverse
  R gets transferred in f/forward direction
Done: -Implement @show for bond_spectrum 
Done: -Clean up the whole parse links mess to handle iMPOs
Done: -Support make_transIsing_iMPO
Done: -For the make hamiltonian functions put ul,hx,J into kwargs
  This will tie in with using the Model("model_name") framework Matt is using.
Done: -Review all examples.  Add iMPO example.
Can't do (for now: -Reproduce 30 site example from Parker paper.
  I estimate Dw>>1000 for N=30.  They must be building H_hand more efficiently.
  Anyway for N=9 we get Dw=206 which truncates nicely to Dw=9, takes about a minute just to build up H though!
Done:  Need to build H-3body from scratch.
Done:  Need code for W_1 + W_2
Done: -Try using cutoff instead of truncate=false for autoMPO
Done: -Clean up iMPO truncate code.
Done: -Move i_orthog code into orthogonalize.jl files
Done: -Review generated docs, upgrade for iMPO support.
Done: -QN support for InfiniteSum code.
Done: -Use Itensor spectrum instead of bond_spectrum.
Done: -Use sweep(H,lr) instead of the if blocks.
Done: -Refactor the H[n]*U dag(U)*H[n+1] code for iMPO truncate.

Done: 1) Not seeing any rank reduction
Done: 2) Upgrade tests to use ~ and atol.
Done: 3) Upgrade tests to use for loops.
Done: 4) ITensorMPOCompression/test/hamiltonians.jl
Done: Deal with: Calling `inner(x::MPS, A::MPO, y::MPS)` where the site indices of the `MPS`
â”‚ `x` and the `MPS` resulting from contracting `MPO` `A` with `MPS` `y` don't
â”‚ match is deprecated as of ITensors v0.3 and will result in an error in ITensors
â”‚ v0.4. The most common cause of this is something like the following:
Done: 6) orthogonalize! -> ITensors.orthogonalize! for proper overloading
Done: 7) truncate! -> ITensors.truncate! for proper overloading
Done: 8) Use iq returned from qr()
Yes:  9) Do we still need disable_debug_checks before calling dmrg() ?


Done: -make block_qx return link name qx instead of ql,lq,qr,rq
Done: -calculate getV,setV offsets from matrix_state
Done: -We need pure upper/lower enums without diagonal and full options
Done: -further simplify the compress H loop
Doen: -Need to save SV spectrum somewhere
Done: -Look into the MPS compession code for inspiration.
Done:    rename compress! to trunctate! (supprts the svd args)
        cutoff  Using a cutoff allows the SVD algorithm to truncate as many states as possible while still ensuring a certain accuracy.

        maxdim â€“- integer M. If the number of singular values exceeds M, only the largest M will be retained.

        mindim â€“- integer m. At least m singular values will be retained, even if some fall below the cutoff
    rename canonical! to orthogonalize! and orthogonalize (support left/right rankreveal)

Done: -Figure out how to turn off asserts for performance.
-consistent variable names for link indexs: ir,ic,iq,iu,iv ?
Fixed: #grow(i1,W,i2) relies on index ordering inside W ... is that bad?? (hint:yes!)
Done: -grow(i1,W,i2) --> grow(W,i1,i2)
Done: -Fix known fail for compressing when H has 8 NNN  Do tidy up items first.
Done -Get RQ decomp going. in order to ....
Done -Support upper-tri MPOs
Done: -Support rank releavling QR,RQ,QL,LQ
Done: -Clean up canonical and compress code.
Done: -reduce two block_qx functions to one
Done: -Do we need to copy W in block_qx? Yes
-Comment indices in orthogonalize!(...)
Done: -use index returned by ql,qr,lq,rq
Done -We need rank reaving QR/QL/RQ/LQ throughout, otherwise we get zero col/rows away from the edges which causes no end of trouble.
-is_regular is looking along the wrong diagonal for upper rectangular.  Not sure any more
Fixed: -for lower,right SetV seems to require the last column(above I)  should be preserved ... 
  but why?       It should be zeros.  Index ordering?
Done: -Make rank reaviling an option for block_qx
Done: -For obc MPO try compressing 2..N-1, what do we end up with for W[N].  Then try N..2, what does W[1] look like??  Can we get around PBC issue this way?
Done: -Test canonical with rr_cutoff=0.0 and compare.  need an maxlinkdim(H::MPO) function.  
-Use  # Exact energy for transverse field Ising model J=-1, hx=-1
    # with open boundary conditions at criticality
    energy_exact = 1.0 - 1.0 / sin(Ï€ / (4 * N + 2))
    @test abs((energy - energy_exact) / energy_exact) < 1e-4
    Can we get fast convergence for small lattices?
Done: -add Printf for 
Done: -simplify MPOpbc code
Done: -Get rid of MPOpbs struct.
Done: -Prevent Documter.jl from showing ITensor docs.
Done: -Seeing flakey GS tests.  probably need to seed the randomMPS for consistency.
Done: -Add a big lattice test and look at SVs
Plan:
  90% Document what I have so far
  Done: Test with fixed autoMPO Hamiltonians (start the heisenberg with arbitrary neighbours)
  Done: Test with DMRG GS calculations (should just work, but who knows right?)
  Test with Fermion/Hubbard  Hamiltonians
  Test with the 3 body hamiltonians used in the Parker paper (If I can figure what they were doing)
  Test with QN's (new area for me)
  50% Refactor the code.  A lot of things can be simplified once there are lots of unit tests in place.
  Done: Figure how to disable 100's of asserts for production mode usage.  
  Done: Incoroprate make_Ham functions into module
  Done: Organize exports
  90% Add examples to docs (needs make_Ham functions)
  

Matts emails:
Nice meeting you and thanks again for offering to help us out with the development of ITensor!

Here are the Julia development tools that were brought up, and some other ones I thought of:

Julia debuggers (the primary ones appear to be the one built into the Julia VSCode extension and Debugger.jl):
https://opensourc.es/blog/basics-debugging/
https://www.julia-vscode.org/docs/stable/userguide/debugging/
https://github.com/JuliaDebug/Debugger.jl

Julia vim plugin:
https://github.com/JuliaEditorSupport/julia-vim

OhMyREPL for nice syntax highlighting in the Julia REPL:
https://github.com/KristofferC/OhMyREPL.jl

Revise is absolutely critical for developing Julia packages, since it allows you to edit code when you are developing Julia packages and have the changes immediately reflected outside the package, without restarting the Julia session:
https://github.com/timholy/Revise.jl

I would also recommend using the JuliaMono font to help with viewing unicode (many fonts have limited unicode support):
https://juliamono.netlify.app/

Here is the profile visualization tool I use:
https://github.com/timholy/ProfileView.jl

For a graph visualization of the profile you can use:
https://github.com/JuliaPerf/PProf.jl
https://opensourc.es/blog/constraint-solver-profiling/

And here is the code I wrote for making an operator valued matrix from an MPO:
https://github.com/ITensor/ITensorInfiniteMPS.jl/blob/main/src/vumps_mpo.jl#L36-L64

We actually have an immediate application of the MPO compression in Julia (there is an intern working on a project where he is renormalizing a local Hamiltonian by a unitary circuit, so it would be great to automatically compress the MPO instead of computing the new Hamiltonian more manually). I also have some quantum chemistry applications where that would be useful. I think that would be a top priority, though of course feel free to work on whatever peaks your interest most.

I don't think you need any particular Hamiltonian. A useful test would be to start with any local Hamiltonian (say the Heisenberg model) and time evolve it by any local local circuit, it could even be totally random gates. I'm attaching an example you could start from.

Unfortunately there is a slightly circular logic in this example, since the lines:

UHU = apply(U, H; apply_dag=true, cutoff=1e-15)

that performs the circuit evolution also does an MPO truncation, however it uses the naive form of truncation that treats the MPO as a state. It would also take the MPO out of the upper/lower triangular form. So I guess we would have to think about how the basis rotation should actually be applied in this case. Ultimately the goal would be for the apply have an option where you can specify the MPO should be treated as a local Hamiltonian and truncated using the Parker et al. algorithm.

Let me know if you think that example makes sense and if there is a way you could make use of it. Perhaps it is best to think about it in terms of just applying one of the gates of the circuit at a time, and truncating just the bond where it is applied. In that way, we could engineer the gate so it is applied at first without truncation and then truncated using the Parker et al. algorithm.

Also, maybe it is helpful to know that you can turn the circuit into an MPO like this:

Id = MPO(OpSum() + ("Id", 1), s)
Umpo = apply(U, Id; cutoff=1e-15)

That form could make it easier to apply the circuit (or just a gate) to the Hamiltonian MPO to keep it in a form where it can be used with the Parker et al. algorithm.

